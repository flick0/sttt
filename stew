from dataclasses import dataclass
from curses import wrapper
import time
import curses

def make_line(stdscr, i):
    height,width = stdscr.getmaxyx()
    if i >= height:
        return False
    try:
        stdscr.addstr(i, 0, "█" * width)
    except curses.error:
        return False
    return True

def set_pix(stdscr, x,y, char="█"):
    height,width = stdscr.getmaxyx()
    if x >= width:
        return False
    if y >= height:
        return False
    try:
        stdscr.addstr(y, x, char)
    except curses.error:
        pass
    return True

class Transition:
    screen: curses.window
    width: int
    height: int

    duration: float
    
    start_time: float

    loop: bool
    reverse: bool
    debug: bool = False

    def __init__(self, screen:curses.window, duration:float, loop:bool = False,reverse:bool = False,debug:bool = False):
        self.screen = screen
        self.duration = duration
        self.start_time = time.time()
        self.height, self.width = screen.getmaxyx()
        self.loop = loop
        self.debug = debug
        self.reverse = reverse

    def update_dim(self):
        self.height, self.width = self.screen.getmaxyx()

    def frame_for_instant(self, now:float):
        time = (now - self.start_time)/self.duration
        return self.frame_for_time(time)
        
    
    def frame_for_time(self, time:float):
        last_frame = False
        if self.loop:
            if self.reverse:
                time = time%2
                if time > 1:
                    time = 2 - time
            else:
                time = time%1
        elif time < 0:
            time = 0
        elif time >= 1:
            time = 1
            last_frame = True
        self.screen.clear()
        for pix in range(self.height*self.width):
            x = pix % self.width
            y = pix // self.width
            self.draw(x,y,time)
        if self.debug:
            set_pix(self.screen, 0,0,char="time: "+str(time))
        self.screen.refresh()
        return not last_frame

    def draw(self,x,y, time):
        set_pix(self.screen, x,y)
        set_pix(self.screen, 0,0,char="time: "+str(time))



class ScanLine(Transition):
    def draw(self,x,y,time):
        current_line = int(time * self.height)
        if y == current_line:
            set_pix(self.screen, x,y)
            
class Grow(Transition):
    center_x: int
    center_y: int
    def __init__(self,*args,**kwargs):
        super().__init__(*args,**kwargs)
        self.center_x = self.width//2
        self.center_y = self.height//2

    def update_dim(self):
        super().update_dim()
        self.center_x = self.width//2
        self.center_y = self.height//2
    
    def draw(self,x,y,time):
        dist_x = abs(x - self.center_x)/2
        dist_y = abs(y - self.center_y)
        dist = (dist_x**2 + dist_y**2)**0.5

        max_dist = ((self.width/4)**2 + (self.height/2)**2)**0.5

        if dist < time * max_dist:
            set_pix(self.screen, x,y)


def main(stdscr):
    # Clear screen
    stdscr.clear()
    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_BLACK, -1)
    
    make_frame = True

    transition = Grow(stdscr, 1, loop=True, reverse=True, debug=True)

    while make_frame:
        current_width,current_height = stdscr.getmaxyx()
        if transition.width != current_width or transition.height != current_height:
            transition.update_dim()
        if not transition.frame_for_instant(time.time()):
            break

    stdscr.refresh()
    stdscr.getkey()

wrapper(main)